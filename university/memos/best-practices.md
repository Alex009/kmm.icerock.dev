---
sidebar_position: 0
---

# Best Practices

## Введение
На этой странице перечислены наиболее распространенные ошибки, которые, как правило, новички повторяют не один раз, что существенно увеличивает время ревью. Однако, большинство из этих ошибок совсем не сложные и их легко заметить и исправить самостоятельно. Это позволит существенно сократить время прохождения ревью и быстрее стать крутым разработчиком ;)  
Ошибки структурированы по трем частям
- Common
- iOS 
- Android

Для самопроверки, обращайтесь к тому разделу, котормы вы сейчас занимаетесь.  

## Общее
- Продумывайте имена функций и их содержимое, [памятка](function)
- Не пытайтесь реализовать то, что есть в системе. Если что-то в дизайне немного отилчается от системного варианта (алерт, тулбар, кнопка "назад") - спросите у руководителя, действительно ли должно 1 в 1 быть как в дизайне. 99%, что системная реализация подходит
- не должно быть никакого хардкода текста, который показывается пользователю
- не работайте с сетевыми сущностями в приложении, преобразуйте их в свои, доменные(приложения), и используйте везде свои
  - Если в приложении вы работаете с сетевыми сущностями, то в случае, если на сервере что-то изменят, завернут какое-то поле или еще что-то подобное, то вам придется исправлять все места, где используется эта сущность. А если при получении сетевой сущности сразу маппите ее в доменную, то при изменении сетевой вам нужно будет просто изменить маппер и все
  - Если с сетевой приходит null, можно как-то заменить на ненул, чтобы в приложении не работать с nullable
- Следите за неймингом! У вас не должно быть переменных и методов, которые не несут в названии никакой информации о том, для чего они, например:
  - `binding.button.setOnCLickListener { buttonClickAction() }` - что это за кнопка и что за метод?
- Используйте автоформатирование после изменения каждого файла
  - `Option` + `Command` + `L` (Android Studio)
  - `Control` + `i` (Xcode)
- Если вы используете State и Actions, то в названии переменных обязательно должно фигурировать, что это state или actions
- Новые зависимости добавляйте сразу в libs, в нужный блок, а не хардкодом [Version Catalog](../../learning/gradle/version-catalogs). (Начиная с 4ого блока)
- Не используйте MR ресурсы на платформе, на андроид есть R, на iOS есть R.swift. (ссылка на четвертый блок, где будет пояснение).
- В мультиплатформенных ресурсах должны быть только те, которые управляются общей логикой, те, которые не управляются - должны лежать на платформе
- ***Не создавайте дополнительную переменную, если сразу же после ее создания присваиваете её куда-то, без каких либо модификаций*** 
  - кейсы добавить
  - перефразировать
- Максимально настраивайте статический UI элемент в xml или xib, не надо его потом донастраивать в коде
- Не используйте форскасты
- Разделяйте классы/интерфейсы/объекты по файлам, [кодстайл](../../learning/code-style/separate-by-files)
- проверять по [кодстайлу](../../learning/code-style/it-in-lambdas) все то, что вы написали.
- Не надо делать велосипед
  - свое действие назад
  - верстать свой алертдиалог
  - версвтать свой тулбар
- кликабельные элементы UI не должны по какой-то логике вызывать методы вьюмодели
- exitButton.setOnClickListener { viewModel.clearPrefs() } - UI не должен говорить вьюмодели - чисти префы
- exitButton.setOnClickListener { viewModel.onExitButtonPressed() } - UI должен говорить вьюмодели - нажми на мою кнопку, а вьюмодель сама уже будет делать то, что надо 
- используйте аннотации `@Throws(...)` толко в случае, если это попадает в swift код
- используйте `weakLambda(...)` - сохранят receiver слабой ссылкой
- проверяйте, что не загрузили в гит всякую фигню, [настройте](https://kmm.icerock.dev/university/memos/gitignore) `.gitignore`
- код не должен содержать никаких дебажных print и закомменченных строк, которые не несут никакой смысловой нагрузки
- Данные из KVS не должны сохраняться в свойства класса, каждый раз надо тянуться до KVS и брать актуальное значение
- свои кастомные эксепшены, которые мы сами кидаем, наследуем от RuntimeException()
- расставляйте элементы UI в xml в хронологическом порядке, а не абы как, чтобы те элементы, которые сверху экрана (тулбар например) объявлялись сверху в xml
- расставляйте элементы UI в xml в хронологическом порядке, а не абы как, чтобы те элементы, которые сверху экрана (тулбар например) объявлялись сверху в xml
- форматирование кода, отключить галку, чтобы не добавлялась лишняя запятая ![img.png](media/useless-comma.png)
- помните про конфикты имен Kotlin и iOS, если у вас будет свойство description, [вот](../../learning/kotlin-multiplatform/mobile-highlights#конфликты-имен-на-ios) что будет на iOS
- все привязки вьюх к вьюмодели помещайте в одну функцию `bindToViewModel`
- не создавайте лишние функции, действия внутри которых итак понятны, без функции, например
  ```kotlin
  fun setupSignInButton(){
    signInButton.setOnClickListener {
      viewModel.onSignInButtonPressed()
    }
  }
  ```
- Константы должны иметь явное название, чтобы по имени было понятно, для чего она нужна. 
  - плохо `const val REPO_NAME = "repo_name"` 
  - хорошо `const val REPO_NAME_ARG_KEY = "repo_name"`
## iOS
- приватные аутлеты
- уделяйте пристальное внимание тому, как вы обрабатываете стейты ***Ссылка про стейты на iOS***
- Если какой-то набор элементов используется на нескольких экранах - выносите его в отдельную UIView и используйте на нужном экране
- Добавляйте текст на элементы, чтобы на дизайне экрана можно было ориентироваться. Не добавляйте такой текст, какой должен быть в готовом приложении, чтобы потом не забыть поменять. Например, для названия кнопки ввода используйте не "Ввод", а "//Ввод", тогда, если бы вы забыли заменить этот текст, то сразу бы увидели это при запуске
- векторные картинки должны быть single scale
- добавление кастомных вьюх должно быть не через код, а через Interface builder 
- проверяйте имя файла картинки, которую скачали с фигмы, оно должно явно обозначать, что это за картинка, аналогично с неймингом переменных
- цвет для контроллера надо устанавливать в AppDelegate, только создали навконтроллер - сразу ставим цвет `navigationController?.navigationBar.barStyle = .black`
- используйте слабые ссылки на self
  - плохо
    ```
    cell.onTap = {
      self.navigationController?...
    }
    ```
  - хорошо
    ```swift
    cell.onTap = { [weak self] in
      self?.navigationController?...
    }
    ```
- сплешскрин делать в LaunchScreen.storyboard, а не в SplashViewController
- чтобы у кнопки "Назад" не было текста - нужно у предыдущего экрана выставить в `navigationItem.backButtonTitle = ""` - навконтроллер берет название для кнопки назад от того экрана, на который будет переход назад производиться
- ключи в классах всегда `private static let` - потому что ключи точно не уникальные для конкретного экзеплятра класса
- устанавливайте в podfile версии подов, их можно посмотреть после pod install в файле Podfile.lock, иначе когда другой разработчик (или ты но на другом компе) будет ставить поды то версии другие подтянутся и есть вероятность что в новой версии чето будет изменено и проект больше не скомпилируется. либо, как щас популярно, в библиотеку всунут зловредный код в новой версии и оно тебе скачается.

## Android
- Используйте константы для отступов в приложении правильно:
  - если дизайнер обозначил, что есть общие значения для некоторых отступов и тд - используйте
  - если обозначения общих размеров и отступов нет - использование на свой страх и риск
  - имена констант должны быть нормальные
  - констант не должно быть адское количество, иначе только путать будут
  - любые константы должны называться относительно контекста использования - background_color, status_bar_color, button_color_default, default_top_margin
- уделяйте пристальное внимание тому, как вы обрабатываете стейты ***ссылка на обработку в андроиде***
- Используйте конструкцию `with(binding...)` для XML элементов правильно. Не стоит ей злоупотреблять, иначе она будет только ухудшать читаемость.
  - примеры Хорошо/плохо
- Если какой-то набор элементов используется на нескольких экранах - выносите его в отдельный layout и подключайте с помощью [include](https://developer.android.com/training/improving-layouts/reusing-layouts)
- Используйте [tools:text](https://developer.android.com/studio/write/tool-attributes), во всех UI элементах, которые содержат поле `text`, чтобы было легче ориентироваться в дизайне экрана ***Это можно просто требованием жестким поставить во все практики***
- ***Про верстку на констрейнтах и без кучи вложенности в другие констрейнты***
- ***Про верстку сверху вниз и снизу вверх, отступы от элементов, которые рядом, а не просто от главного экрана приложения***
  - если элемент расположен внизу экрана - не надо цеплять его к верху - снизу значит снизу 
- Не использовать `bias` для расположения элемента на экране
- проверять savedInstanceState, чтобы не создавать граф заново, также убедитесь, что установили граф в активити 
  - savedInstanceState - переменная для хранения данных из бандла, которая передается в onCreate(). Если данные из бандла пустые или savedInstanceState == null, тогда нужно создать новый навграф, а если нет, то взять данные из памяти, ветка else не нужна, тк логика пересоздания из памяти выполняется в супере onCreate()
- доступ к аргументам нужно через requireArguments(), если его нет - кидать ошибку а не тянуть nullable дальше
  - также, делайте вычисляемые свойства для работы с аргументами
  - плохо `private val something: String = requireArguments().getString(SOMETHING_KEY) ?: throw NoArgumentsException()`
  - хорошо `private val something: String get() = requireArguments().getString(SOMETHING_KEY) ?: throw NoArgumentsException()`
- не надо изменять цвет у корневого Layout, главный цвет должен быть у окна, иначе будет overwrite всех пикселей на экране сразу
- подписываться на вьюмодель должна создаваться сразу, как только мы создали вью
- тема приложения выставляется в AndroidManifest, а не в активити и фрагментах
- во фрагментах надо запускать корутины во viewLifecycleScope, а не lifecycleScope. Т.е. цепляться ко вьюхе, а не к фрагменту (1 блок андроида)
- не запутайтесь с удалением обсервера:
  - так ничего не удалится
  ```kotlin
  private val request = MutableLiveData<...>()
  request.observeForever {
      if (it != null) {
          ...
      }
  }
  request.removeObserver { }
  ```
  - а вот так удалится 
  ```kotlin
  private val request = MutableLiveData<...>()
  private val requestObserver: Observer<...?> = Observer { ... }
  request.removeObserver(requestObserver)
  ```
- на чистом Android при работе со списками не забывайте смотреть [сюда](../..//android/adapter)
- все отступы всегда должны быть кратны 4(8, 16, 24, 32), если в дизайне по-дургому, задавайте вопросы
- используя свои стили, всегда наследуйтесь от дефолтного, чтобы не потерять его настройки
  - не указывайте размеры (width и height) в стилях
- используйте lateinit правильно
  - lateinit это чисто андроидная штука, костыль, чтобы передавать всякие компоненты во фрагменты и активити, потому что мы не можем создать кастомный класс фрагмента или активити, чтобы передавать зависимости в конструктор. Мы даже не можем точно предсказать место, где будет создан объект фрагмента/активити. Поэтому lateinit - это костыль, которого нужно избегать, ибо ты можешь забыть что-нибудь проинитить и все крашнется
- xml называйте аналогично названию класса
  - плохо: DetailRepoInfoFragment и fragment_detail_repo
  - хорошо: DetailInfoFragment и detail_info_fragment

## Перед отправкой на ревью
- Перед каждым коммитом выделяйте 5-7 минут, чтобы отсмотреть все изменения, на наличие ошибок, перечисленных на этой странице  
- Также, после создания итогового merge request, отсмотрите все свои изменения. Благодаря тому, что вы проверяли их после каждого коммита, это не займет у вас слишком много времени.

Такая самопроверка не только позволит вам автоматически не допускать перечисленных ошибок в будущем, но и ускорит ревью вашего MR, потому что в нем уже не будет части ошибок.
