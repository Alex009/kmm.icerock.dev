---
sidebar_position: 4
---

# Реактивный источник данных

## Проблема и решение
Почти во всех приложениях обязательно есть работа с данными, которые мы получаем от сервера, из интернета, от базы данных и т.д.  
Какие-то данные будут отображаться на одном экране приложения, какие-то на двух, а какие-то на трех и более.

Например, приложение любой социальной сети: один пост может быть репостнут разными людьми и группами. У поста есть лайки, комментарии, репосты и просмотры.  
Чтобы на всех экранах отображать данные о постах в актуальном состоянии мы можем закидывать сервер запросами, однако нет гарантии, что мы нигде не ошибемся и где-нибудь не забудем добавить обновление. Из-за этого отображение поста на разных экранах будет отличаться. В любом случае, поддерживать такой проект будет очень тяжело.  

Чтобы избежать всех этих проблем нам нужно использовать такой источник данных, который бы позволил обновлять данные автоматически, а не вручную.  
То, что нам нужно называется ***Реактивный источник данных*** - он выдает реактивные подписки, т.е. что-то, на что мы можем подписаться из `viewModel`. Благодаря этому, при любых обновлениях данных в источнике на экране они также обновятся.   

Как это представлено в проекте: 
- База данных, которая возвращает [Flow](https://developer.android.com/kotlin/flow) объектов, а не просто список
- из `viewModel` мы подписываемся на этот `Flow`

## Пример реализации

Например, у нас есть экран со списком кораблей, по нажатию на элемент списка нужно показать детальную информацию о конкретном корабле на следующем экране.
Создадим [SQLDeight](https://cashapp.github.io/sqldelight/)-таблицу, в которой будет храниться объект `Ship` и флаг `isSelected`. В объекте `Ship` есть вся информация о корабле, а по `isSelected` мы можем понять какой корабль выбран прямо сейчас. Вот как будут выглядеть таблица и запрос: 

```sqldelight
CREATE TABLE ShipsTable (
    id INTEGER AS Int PRIMARY KEY,
    isSelected AS Boolean NOT NULL,
    ship AS Ship NOT NULL,
);

selectedShip:
SELECT *
FROM ShipsTable
WHERE isSelected = true;
```

Реализация метода `selectedShip` будет следующей:

```kotlin
fun getShipById(): Flow<Ship?> {
    return shipsQueries.selectedShip()
        .asFlow()
        .mapToOneOrNull()
        .map { it?.toFeature() }
}
```

Мы возвращаем от таблицы не просто объект `Ship`, а `Flow`, а во `viewModel` подписываемся на этот `Flow`:

```kotlin
val selectedShip: LiveData<Ship> = repository.selectedShip().map {
        it ?: throw IllegalStateException("selected ship can't be null!")
    }.asLiveData(viewModelScope, initialValue = Ship())
```

Если `selectedShip` изменился (выбрали другой корабль), то и `selectedShip` автоматически обновится, потому что результат `repository.selectedShip()` - это `Flow`, а мы на него подписались.  
Таким образом, если данные в таблице изменятся, то все методы, у которых изменилось возвращаемые значение, вызовутся еще раз и все места в приложении, где используются данные из этого запроса, обновятся. Нигде не придется ничего вызывать и обновлять вручную. Данные изменились - UI сразу обновится.

## Практическое задание
Сделайте приложение, которое содержит: 
- Реактивный репозиторий
- Источник данных для репозитория - база данных [SQLDelight](https://cashapp.github.io/sqldelight/)
- Экран со списком элементов, и двумя кнопками
    - данные для списка реактивно тянутся от репозитория
    - по нажатию на первую кнопку в БД добавляется еще один элемент списка (чтобы увидеть реактивность)
    - по нажатию на вторую кнопку БД очищается
