---
sidebar_position: 5
---

# Реактивный источник данных

Почти во всех приложениях обязательно есть работа с данными, которые мы получаем от сервера, из интернета, от базы данных и т.д.  
Какие-то данные будут отображаться на одном экране приложения, какие-то на двух, а какие-то на трех и более.  
Например, приложение любой социальной сети: один пост может быть репостнут разными людьми, группами. У поста есть лайки, репосты, комментарии, просмотры.  
Чтобы всегда держать эти данные в актуальном состоянии мы можем закидывать сервер запросами, однако нет гарантии, что мы нигде не ошибемся и где-нибудь не забудем добавить обновление. В любом случае, поддерживать такой проект будет очень тяжело.  

Чтобы избежать всех этих проблем нам нужно использовать такой источник данных, чтобы не пришлось обновлять все данные вручную.  
То, что нам нужно называется ***Реактивный источник данных*** - он выдает реактивные подписки, т.е. что-то, на что мы можем подписаться со стороны `viewModel`. Таким образом, при любых обновлениях данных экран сразу отобразит актуальные.   

Как это выглядит в проекте: 
- есть База данных
- она возвращает [Flow](https://developer.android.com/kotlin/flow) а не просто список
- со стороны `viewModel` мы подписываемся на этот `Flow`

## Пример

Допустим, у нас есть [SQLDeight](https://cashapp.github.io/sqldelight/)-таблица кораблей и запрос, позволяющий получить интересующий нас корабль из таблицы

```sqldelight
CREATE TABLE ShipsTable (
    id INTEGER AS Int PRIMARY KEY,
    isSelected AS Boolean NOT NULL,
    ship AS Ship NOT NULL,
);

selectedShip:
SELECT *
FROM ShipsTable
WHERE isSelected = true;
```
Реализация метода будет следующей:

```kotlin
fun getShipById(): Flow<Ship?> {
    return shipsQueries.selectedShip()
        .asFlow()
        .mapToOneOrNull()
        .map { it?.toFeature() }
}
```
Мы возвращаем от таблицы не просто список, а `Flow`, а во `viewModel` подписываемся на этот `Flow`.

```kotlin
val selectedShipTitle: LiveData<String> = repository.selectedShip().map {
        it?.title ?: throw IllegalStateException("selected ship can't be null!")
    }.asLiveData(viewModelScope, initialValue = "")
```

Если наш `selectedShip` изменился (выбрали другой корабль), то и `selectedShipTitle` автоматически обновится, потому что результат `repository.selectedShip()` - это `Flow`, а мы на него подписались.
Таким образом, если состояние таблицы будет меняться, то все методы, которые поменяли возвращаемые значения и которые уже используются, вызовутся еще раз. Все места в приложении, где используются данные из этого запроса, обновятся. Нигде не придется ничего вызывать и обновлять руками. Данные изменились - UI сразу обновится.

Отправить посмотреть на эту цепочку на каком-нибудь проекте
1. посмотрите на дизайн экрана, как думаете, что из этого обновляется и должно откуда-то доставаться? 
1. посмотрите на интерфейс репозитория для вьюмодели, вот какие методы ей нужны 
1. посмотрите на реализацию методов (методы для всех репозиториев создаются в одном едином репозитории, этот объект передается всем вьюмоделям)

## Практическое задание
Сделайте приложение: 
- Реактивный репозиторий
- Источник данных для репозитория - база данных [SQLDelight](https://cashapp.github.io/sqldelight/)
- Экран со списком элементов, и двумя кнопками
    - данные для списка реактивно тянутся от репозитория
    - по нажатию на первую кнопку в БД добавляется еще один элемент списка (чтобы увидеть реактивность)
    - по нажатию на вторую кнопку БД очищается
