---
sidebar_position: 4
---

# Реактивный источник данных

Почти во всех приложениях обязательно есть работа с данными, которые мы получаем от сервера, из интернета, от базы данных и т.д.  
Какие-то данные будут отображаться на одном экране приложения, какие-то на двух, а какие-то на трех и более.  
Например, приложение любой социальной сети: один пост может быть репостнут разными людьми, группами. У поста есть лайки, репосты, комментарии, просмотры.  
Чтобы всегда держать эти данные в актуальном состоянии мы можем закидывать сервер запросами, однако нет гарантии, что мы нигде не ошибемся и где-нибудь не забудем добавить обновление. В любом случае, поддерживать такой проект будет очень тяжело.  

Чтобы избежать всех этих проблем нам нужно использовать такой источник данных, чтобы не пришлось обновлять все данные вручную.  
То, что нам нужно называется ***Реактивный источник данных*** - он выдает реактивные подписки, т.е. что-то, на что мы можем подписаться из `viewModel`. Благодаря этому, при любых обновлениях данных в источнике на экране они также обновятся.   

Как это пердставлено в проекте: 
- База данных, которая возвращает [Flow](https://developer.android.com/kotlin/flow) обхектов, а не просто список
- из `viewModel` мы подписываемся на этот `Flow`

## Пример

Допустим, у нас есть [SQLDeight](https://cashapp.github.io/sqldelight/)-таблица кораблей и запрос, позволяющий получить интересующий нас корабль из таблицы:

```sqldelight
CREATE TABLE ShipsTable (
    id INTEGER AS Int PRIMARY KEY,
    isSelected AS Boolean NOT NULL,
    ship AS Ship NOT NULL,
);

selectedShip:
SELECT *
FROM ShipsTable
WHERE isSelected = true;
```
Реализация метода `selectedShip` будет следующей:

```kotlin
fun getShipById(): Flow<Ship?> {
    return shipsQueries.selectedShip()
        .asFlow()
        .mapToOneOrNull()
        .map { it?.toFeature() }
}
```
Мы возвращаем от таблицы не просто объект `Ship`, а `Flow`, а во `viewModel` подписываемся на этот `Flow`:

```kotlin
val selectedShipTitle: LiveData<String> = repository.selectedShip().map {
        it?.title ?: throw IllegalStateException("selected ship can't be null!")
    }.asLiveData(viewModelScope, initialValue = "")
```

Если `selectedShip` изменился (выбрали другой корабль), то и `selectedShipTitle` автоматически обновится, потому что результат `repository.selectedShip()` - это `Flow`, а мы на него подписались.
Таким образом, если данные в таблице измеятся, то все методы, у которых изменилось возвращаемые значение, вызовутся еще раз и все места в приложении, где используются данные из этого запроса, обновятся. Нигде не придется ничего вызывать и обновлять вручную. Данные изменились - UI сразу обновится.

## Практическое задание
Сделайте приложение: 
- Реактивный репозиторий
- Источник данных для репозитория - база данных [SQLDelight](https://cashapp.github.io/sqldelight/)
- Экран со списком элементов, и двумя кнопками
    - данные для списка реактивно тянутся от репозитория
    - по нажатию на первую кнопку в БД добавляется еще один элемент списка (чтобы увидеть реактивность)
    - по нажатию на вторую кнопку БД очищается
