---
sidebar_position: 9
---

# Логирование и обработка ошибок

## Логирование

В проекте необходимо правильно логировать ошибки, потому что при выпуске приложения получается

Рассмотрим ситуацию, в которой мы бы не заботились о логировании на протяжении всей работы над проектом. Успешно его завершили, протестировали и отдали заказчику.
Спустя какое-то время, как приложением начали пользоваться юзеры, получаем сообщение от заказчика, что пользователи жалуются на то, что у них без какой-либо системы крашится приложение.

Мы начинаем искать ошибки и причины краша приложения. Все, что нам о них известно - что они происходят на нескольких экранах без какой-либо системы.  
Попробовали воспроизвести ошибки - не получилось. Проверили код нескольких проблемных экранов - тоже вроде бы все в порядке, проблемные места обработаны.  
Остается последний вариант - пробовать воспроизводить ошибки, чтобы определить в каком месте и по какой причине они происходят. Всей командой пытаемся добиться креша приложения, но у нас все работает, ни одного креша за целый день.
Наконец, спустя еще N времени кому-нибудь удалось достичь креша, и исправили силами одного разработчика за 30 минут.  

Согласитесь - бороться таким образом с каждой ошибкой не самый хороший вариант. 

Чтобы избежать этого, мы используем сервис [Firebase Crashlytics](https://firebase.google.com/docs/crashlytics), который позволяет получать данные обо всех ошибках, которые произошли у юзеров на устройствах, без какого либо участия с их стороны.  
Сервис позволяет ловить два вида ошибок:
  - `fatal` - произошел прям краш приложения
  - `non-fatal` - произошла ошибка, однако, она была как-то обработана (`try catch`)

Как реагировать на с `fatal` и `non-fatal` ошибки:
- fatal:
  - раз приложение крашнулось, значит где-то произошла ошибка, которая никак не обрабатывается. Наши действия: добавим обработчик ошибкок в то место, где она произошла, добавим логирование средствами в `Firebase Crashlytics`, чтобы все следующие ошибки в этом месте попадали в `Firebase`, но уже как `non-fatal`
- non-fatal:
  - раз произошла `non-fatal` ошибка, значит проблемное место мы уже обрабатываем и логируем
  
Рассмотри `non-fatal` ошибки подробнее:
Какими они бывают:
  - это новая ошибка, которая произошла из-за косяка в нашем коде
  - это стандартная ошибка, например, из-за отсутствия интернета, или нехватки памяти на устройстве, чтобы сохранить файл

Если ошибка произошла из-за какого-то недочета в коде - мы просто исправим код и все.  

Если же эта ошибка стандартная - мы изменим условие логирования, чтобы больше не видеть информацию об этой ошибке в `Firebase`. Это поможет нам избавиться от информации о куче `non-fatal` ошибок, и, когда произойдет какая-то новая ошибка, мы сразу это заметим и пойдем разбираться, а не пропустим ее в общей куче ошибок.

Теперь, когда нам снова напишет заказчик и сообщит, что у юзеров опять крашится приложение, наш план будет следующим:
- открываем `Firebase Crashlytics`, видим, какая ошибка происходит у пользователей
- оперативно исправляем ошибку

Для логирования в общем коде мы используем библиотеку [Napier](https://github.com/AAkira/Napier), которую связываем с `FirebaseCrashlytics`, чтобы логируя используя `Napier`, логи автоматически попадали и в `Firebase`.

Поэтому, при разработке нового проекта логи проставляются как минимум во всех обработчиках ошибок.

Также, если заранее удается понять, что какая-то информация каждого конкретного запуска приложения может пригодиться для последующего исправления ошибки, ее также следует логировать с уровнем `INFO`. Однако, никакие секретные ключи и пароли логировать нельзя.


## Обработка ошибок в общем коде

В любом мобильном приложении происходят ошибки. 
Некоторые из них не фатальны и, наоборот, полезны, например - ошибка запроса из-за отсутствия соединения. Такие ошибки нужно правильно обрабатывать, а не тупо скрывать, потому что тогда юзер так и не узнает, в чем проблема, хотя проблема банально в том, что он забыл включить интернет. 
Такие ошибки, как правило, показываются юзеру как аллерт или тост, чтобы юзер успел посмотреть, в чем проблема и, самое главное, попробовал решить ее самостоятельно. 
Также, сообщение о произошедшей ошибке должно содержать достаточно информации для ее решения, от сообщения ОШИБКА!!! об ошибке отсутствия сети будет мало толку

Мы в IceRock используем для этого библиотеку [moko-errors](https://github.com/icerockdev/moko-errors).  
С ее помощью мы можем:
- настроить обработчик ошибок прямо в общем коде
- выбрать, как показывать ошибку юзеру (тост или алерт)
- Использовать разные строки для разных ошибок, прямо в общем коде

## Практическое задание

- склонируйте себе moko-errors
- запустите sample, потыкайте, посмотрите как работает, убедитесь что все работает на обеих платформах
- добавьте alertErrorPresenter, настройте, посмотрите как работает , убедитесь что все работает на обеих платформах
- добавьте свой класс ошибки, по аналогии с `CustomException`, добавьте свою строку локализации для отображения информации об этой ошибке, убедитесь что все работает на обеих платформах
- склонируйте себе mobile-moko-bolirplate, посмотрите как создается ExceptionMappersStorage, функция createExceptionHandler, как прокидывается в фабрику фичей
