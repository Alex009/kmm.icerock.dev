---
sidebar_position: 2
---

# Многомодульность

Мы в IceRock придерживаемся подхода многомодульности  

- ***Что такое модуль?***
    - Модуль - это объединенные одной задачей классы, функции, интерфейсы, структуры и тд. Модули могут зависеть от других модулей, однако делать это нужно только тогда, когда это действительно необходимо  
      Модуль знает о других модулях только то, что ему нужно для корректной работы в рамках самого себя   
    Примеры модулей:
      - common код - мультиплатформенный модуль
      - Фичи приложения - отдельные модули
      - data class, который необходим нескольким фичам - модуль

- ***Зачем вообще эти модули? Пусть бы все лежало в одном месте?***
  - Причина - время сборки iOS-приложения, [видео-описание](https://youtu.be/kO8RDq6OoV4?t=1429) проблемы
  - Начнем с разбора процесса сборки проекта для iOS и Android:
     - За сборку на Android отвечает gradle и компилятор Kotlin Jvm.
       Gradle умеет хранить кеш уже собранного ранее модуля. Ориентируясь на это, он может определять какие модули действительно изменились или зависят от изменившихся.  
       Kotlin Jvm поддерживает инкрементальную компиляцию. Если в двух словах, то это похоже на кеши гредла, только он хранит уже скомпилированные файлы. Почитать подробнее можно [тут](https://blog.jetbrains.com/kotlin/2020/09/the-dark-secrets-of-fast-compilation-for-kotlin/). Таким образом, ориентируясь на них, и на то, какие изменения были сделаны (в public или private api) он может пересобирать только реально изменившийся модуль и добавлять его к уже собранным файлам. Те, кто от него зависят будут пересобраны только в случае изменений в public api
     - Сборкой iOS приложения вместе с gradle занимается Kotlin Native, который не поддерживает инкрементальную компиляцию. Из-за этого, при сборке iOS приложения мы можем ориентироваться только на кеши гредла. Если бы мы не пользовались гредлом, то нам пришлось бы целиком пересобирать весь проект после каждого нового изменения. Таким образом, на iOS мы пересоберем модуль с изменениями и все те, которые от него зависят

  - Пример. У нас есть 6 модулей, `A`, `B`, `C`, `D`, `E` и `F`. Зависимости модулей друг от друга представлены на графе
    ```mermaid
        flowchart TD
         A --> B
         B --> C
         C --> F
         B --> D
         C --> E
        
    ```
    Разберем, как будет происходить сборка приложения для iOS и Android в двух случаях:
    - Разработчик сделал изменение в public api модуля `F`
    - Разработчик сделал изменение в private api модуля `F`

    | api | Платформа | Выводы gradle | Выводы компилятора | Какие модули будут собираться | Время сборки |
    |---|---|---|---|---|---|
    | private |	Android | В зависимостях ничего не поменялось, в source-файлах тоже, значит можно ориентироваться на то, что я (gradle) собрал ранее. Hash модуля `F` изменился, пойду скажу компилятору чтобы собрал модуль `F` и все, которые от него зависят, это `С`, `B` и `A`| Gradle мне говорит, что нужно пересобрать модули `A`, `B`, `C` и `F`. У меня лежат заранее скомпилированные все эти модули, я(компилятор Kotlin JVM) вижу что hash изменился только у модуля `F`. Поскольку изменение было в private api, значит модули, зависящие от `F` можно не трогать, буду пересобирать только модуль `F`| `F` |быстро   
    | private |	iOS | В зависимостях ничего не поменялось, в source-файлах тоже, значит можно ориентироваться на то, что я (gradle) собрал ранее. Hash модуля `F` изменился, пойду скажу компилятору чтобы собрал модуль `F` и все, которые от него зависят, это `С`, `B` и `A` | Я (компилятор Kotlin Native) хочу пересобрать весь проект целиком, но gradle мне сказал, что нужно собрать только модули `A`, `B`, `C` и `F`. Окей | `A`, `B`, `C`, `F` | медленно
    | public | Android | ***то же самое что выше?*** | ***?*** | `A`, `B`, `C`, `F` ***?***  | ***все равно ведь быстрее чем на iOS?*** |
    | public | iOS | ***то же самое что выше?*** | ***как в прошлый раз на iOS?*** | `A`, `B`, `C`, `F` | ***долго*** |

- ***Что мне выносить в модули?***
    - Если вы добавляете новую фичу - добавляйте ее сразу новым модулем
    - Если видите, что какая-то структура или функция понадобится нескольким фичам, вынесите её в новый модуль.
    - Также, следите за тем, чтобы модули не зависели от тех, которые часто меняются. Например, если в модуле будут лежать строки локализации, которые стабильно пополняются и меняются на протяжении всей разработки проекта. Это приведет к тому, что зависящий от него модуль будет пересобираться каждый раз, когда добавляется или исчезает строка локализации 

## Shaper
Любое приложение - это набор фичей. Значит, часто приходится добавлять новые.  
Проблема - когда требуется создать новую фичу, то нужно сделать множество рутинных действий:

1. Создать директорию под новую фичу
1. Скопировать с другой фичи `build.gradle` для новой
1. Завести директорию `src/commonMain/kotlin` со структурой пакетов по packageId модуля
    1. `di`
    1. `model`
    1. `presentation`
1. Завести `src/androidMain/AndroidManifest.xml` с указанием там уникального `packageId`
1. Добавить `include` фичи в `settings.gradle` 
1. Подключить фичу в `mpp-library`

Это только начало создания фичи, далее потребуется создать layout-файлы, Fragment-ы для Android, ViewController-ы для iOS и многое другое  
Чтобы не заниматься этим каждый раз вручную, мы в IceRock сделали генератор, который позволяет создать фичу, модуль, фрагмент, контроллер и прочее всего в несколько кликов!

Генератор - [Shaper](https://github.com/icerockdev/shaper/), [База шаблонов](https://gitlab.icerockdev.com/scl/boilerplate/mobile-shaper-templates)

## Практика
- Запустите [mobile-moko-boilerplate](https://gitlab.icerockdev.com/scl/boilerplate/mobile-moko-boilerplate)
- Добавить `ProfileFragment` вручную
    - пакет - `ru.4test.package`
    - название layout.xml - `profile_fragment`
    - добавьте базовые методы для каждого фрагмента: `viewModelFactory`, `onViewCreated`, `viewBindingInflate`, ориентируясь на [файл для генерации](https://gitlab.icerockdev.com/scl/boilerplate/mobile-shaper-templates/-/blob/master/android/fragment/fragment.kt.hbs)
- Проделайте те же самые действия при помощи [shaper](https://github.com/icerockdev/shaper/), рекомендуем сначала попробовать сделать это самостоятельно, не пользуясь [Памяткой](/university/memos/shaper)
