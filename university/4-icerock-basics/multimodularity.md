---
sidebar_position: 2
---

# Многомодульность

Мы в IceRock придерживаемся подхода многомодульности. 

- ***Что такое модуль?***
    - Модуль - это объединенные одной задачей классы, функции, интерфейсы, структуры и тд. Модули могут зависеть от других модулей, однако делать это нужно только тогда, когда это действительно необходимо 
      Модуль знает о других модулях только то, что нужно ему для корректной работы в рамках самого себя.  
    Примеры модулей:
      - common код - мультиплатформенный модуль
      - Фичи приложения - отдельные модули
      - data class, который необходим нескольким фичам - модуль

- ***Зачем вообще эти модули? Пусть бы все в одном месте лежало и все?***
  - Причина - время сборки iOS-приложения, [видео-описание](https://youtu.be/kO8RDq6OoV4?t=1429) проблемы
  - Начнем с разбора процесса сборки проекта для iOS и Android:
     - За сборку на Android отвечает gradle и компилятор Kotlin Jvm.
       Gradle умеет хранить кеш уже собранного ранее модуля. Ориентируясь на это, он может пересобирать только те модули, которые действительно изменились или зависят от изменившихся.
     - Сборкой iOS приложения вместе с gradle занимается Kotlin Native.  
       Kotlin Jvm - поддерживает инкрементальную компиляцию. Если в двух словах, то это похоже на кеши гредла, только он хранит уже скомпилированные файлы. Почитать подробнее можно [тут](https://blog.jetbrains.com/kotlin/2020/09/the-dark-secrets-of-fast-compilation-for-kotlin/). Таким образом, ориентируясь на них, и на то, какие изменения были сделаны (в public или private api) он может пересобирать только реально изменившийся модуль и добавлять его к уже собранным файлам. Те, кто от него зависят будут пересобраны только в случае изменений в public api
       Он не поддерживает инкрементальную компиляцию. Если бы мы не пользовались градлом вместе с ним, то нам пришлось бы пересобирать весь проект целиком, после каждого нового изменения. Благодаря градлу, при сборке iOS приложения мы можем ориентироваться хотя бы на кеши модулей. Таким образом, на iOS мы пересоберем модуль с изменениями и все те, которые от него зависят

  - Пример. У нас есть 6 модулей, `A`, `B`, `C`, `D`, `E` и `F`. Зависимости модулей друг от друга представлены на графе
    ```mermaid
        flowchart TD
         A --> B
         B --> C
         C --> F
         B --> D
         C --> E
        
    ```
    Разберем, как будет происходить сборка приложения для iOS и Android в двух случаях:
    - Разработчик сделал изменение в public api модуля `F`
    - Разработчик сделал изменение в private api модуля `F`

    | api | Платформа | Выводы gradle | Выводы компилятора | Какие модули будут собираться | Время сборки |
    |---|---|---|---|---|---|
    | private |	Android | В зависимостях ничего не поменялось, в source-файлах тоже, значит можно ориентироваться на то, что я собрал ранее. Hash модуля `F` изменился, пойду скажу компилятору чтобы собрал модуль `F` и все, которые от него зависят, это `С`, `B` и `A`| Gradle мне говорит, что нужно пересобрать модули `A`, `B`, `C` и `F`. У меня лежат заранее скомпилированные все эти модули, я вижу что hash изменился только у модуля `F`. Поскольку изменение было в private api, значит модули, зависящие от `F` можно не трогать, буду пересобирать только модуль `F`| `F` |быстро   
    | private |	iOS | В зависимостях ничего не поменялось, в source-файлах тоже, значит можно ориентироваться на то, что я собрал ранее. Hash модуля `F` изменился, пойду скажу компилятору чтобы собрал модуль `F` и все, которые от него зависят, это `С`, `B` и `A` | Я хочу пересобрать весь проект целиком, но gradle мне сказал, что нужно собрать только модули `A`, `B`, `C` и `F`. Окей | `A`, `B`, `C`, `F` | медленно
    | public | Android | то же самое что выше | ? | `A`, `B`, `C`, `F` ?  |все равно ведь быстрее чем на iOS |
    | public | iOS | то же самое что выше | как в прошлый раз на iOS | `A`, `B`, `C`, `F` | долго |

- ***Что мне выносить в модули?***
    - В основном, модулями у нас в проектах становятся новые фичи, различные структуры данных и фунции, которые будет использоваться сразу несколькими фичами. Таким образом, если вы добавляете новую фичу - добавляйте ее сразу новым модулем. Если видите, что какая-то похожая структура понадобится несколькими фичами, можете вынести её в один модуль.  
      ***Переписать ->*** Также, следите за тем, чтобы модули не зависели от тех, которые часто меняются. Например, если в модуле будут лежать строки локализации, от модуля со строками локализации, которые стабильно пополняются и меняются на протяжении всей разработки проекта

## Shaper
Любое приложение - это набор фичей. Значит, часто приходится добавлять новые.  
Проблема - когда требуется создать новую фичу, то нужно сделать множество рутинных действий:

1. Создать директорию под новую фичу
1. Скопировать с другой фичи `build.gradle` для этой
1. Завести `src/commonMain/kotlin` и структуру пакетов в нем по packageId модуля
    1. `di`
    1. `model`
    1. `presentation`
1. Завести `src/androidMain/AndroidManifest.xml` с указанием там уникального `packageId`
1. Добавить фичу в `settings.gradle` в `include`
1. Добавить фичу в `build.gradle` от `mpp-library` для подключения

Это только начало создания фичи, потом потребуется создать layout-файлы, Fragment-ы для Android и ViewController-ы для iOS и многое другое  
Чтобы не заниматься этим каждый раз вручную, мы в IceRock сделали генератор, который позволяет создать фичу, модуль, фрагмент, контроллер и пр всего в несколько кликов!

Генератор - [Shaper](https://github.com/icerockdev/shaper/), [База шаблонов](https://gitlab.icerockdev.com/scl/boilerplate/mobile-shaper-templates)

## Практика
- Запустите [mobile-moko-boilerplate](https://gitlab.icerockdev.com/scl/boilerplate/mobile-moko-boilerplate)
- Добавить модуль вручную
- Добавьте модуль при помощи [shaper](https://github.com/icerockdev/shaper/), рекомендуем сначала попробовать сделать это самостоятельно, не пользуясь [Памяткой](/university/memos/shaper)
