---
sidebar_position: 2
---

# Многомодульность

Мы в IceRock придерживаемся подхода многомодульности. 

- ***Что такое модуль?***
    - Модуль - это объединненные одной задачей классы, фукнции, интерфейсы, струкруты и тд. Модули могут зависеть от других модулей, однако делать это нужно только тогда, когда это действительно необходимо 
      Модуль знает о других модулях только то, что нужно ему для корректной работы в рамках самого себя.  
    Примеры модулей:
      - common код - мультиплатформенный модуль
      - Фичи приложения - отдельные модули
      - data class, который необходим нескольким фичам - модуль

- ***Зачем вообще эти модули? Пусть бы все в одном месте лежало и все?***
  - Причина - время сборки iOS-приложения
  - Начнем с разбора процесса сборки проекта для iOS и Android:
     - За сборку на Android отвечает gradle и компилятор Kotlin Jvm.
       Gradle умеет хранить кеш уже собранного ранее модуля. Ориентируясь на это, он может пересобирать только те модули, которые действительно изменились или зависят от изменившихся.
       Kotlin Jvm - поддерживает инкрементальную компиляцию. Если в двух словах, то это похоже на кеши гредла, только он хранит уже скомпилированные файлы. Почитать подробнее можно [тут](https://blog.jetbrains.com/kotlin/2020/09/the-dark-secrets-of-fast-compilation-for-kotlin/). Такимм образом, ориентируясь на них, и на то, какие изменения были сделаны (в public или private api) он может пересобирать только реально изменившийся модуль и добавлять его к уже собранным файлам. Те, кто от него зависят будут пересобраны только в случае изменений в public api
     - Сборкой iOS приложения вместе с gradle занимается Kotlin Native.  
       Он не поддерживает инекрементальную компиляцию. Если бы мы не пользовались градлом вместе с ним, то нам пришлось бы пересобирать весь проект целиком, после каждого нового изменения. Благодаря градлу, при сборке iOS приложения мы можем ориентироваться хотя бы на кеши модулей. Таким образом, на iOS мы пересоберем модуль с изменениями и все те, которые от него зависят

- Пример. У нас есть 6 модулей, `A`, `B`, `C`, `D`, `E` и `F`. Зависимости модулей друг от друга представлены на графе
    ```mermaid
        flowchart TD
         A --> B
         B --> C
         C --> F
         B --> D
         C --> E
        
    ```
    Разберем, как будет происходить сборка приложения для iOS и Android в двух случаях:
    - Разработчик сделал изменение в public api модуля `F`
    - Разработчик сделал изменение в private api модуля `F`

| api | Платформа | Выводы gradle | Выводы компилятора | Какие модули будут собираться | Время сборки |
|---|---|---|---|---|---|
| private |	Android | В зависимостях ничего не поменялось, в source-файлах тоже, значит можно ориентироватья на то, что я собрал ранее. Hash модуля `F` изменился, пойду скажу компилятору чтобы собрал модуль `F` и все, которые от него зависят, это `С`, `B` и `A`| Gradle мне говорит, что нужно пересобрать модули `A`, `B`, `C` и `F`. У меня лежат заранее скомпиленные все эти модули, я вижу что hash изменился только у модуля `F`. Поскольку изменение было в private api, значит модули, зависящие от `F` можно не трогать, буду пересобирать только модуль `F`| `F` |быстро   
| private |	iOS | В зависимостях ничего не поменялось, в source-файлах тоже, значит можно ориентироватья на то, что я собрал ранее. Hash модуля `F` изменился, пойду скажу компилятору чтобы собрал модуль `F` и все, которые от него зависят, это `С`, `B` и `A` | Я хочу пересобрать весь проект целиком, но gradle мне сказал, что нужно собрать только модули `A`, `B`, `C` и `F`. Окей | `A`, `B`, `C`, `F` | медленно
| public | Android | то же самое что выше | ? | `A`, `B`, `C`, `F` ?  |все равно ведь быстрее чем на iOS |
| public | iOS | то же самое что выше | как в прошлый раз на iOS | `A`, `B`, `C`, `F` | долго |

объяснить в каком случае пора делать новый модуль, а когда еще нет

показать как сделать новый модуль и подключить ручками и шейпером

Мне кажется текста и скринов хватит

Практика - скачать бойлерплейт, запустить что все хорошо работает
- добавить модули ручками
- добавить модули шейпером 
