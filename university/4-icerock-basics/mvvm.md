---
sidebar_position: 4
---

# Архитектура MVVM

В этом блоке мы разберем архитектурный подход MVVM, паттерн Observer и библиотеку moko-mvvm

Каждый проект состоит в основном из фичией, т.е. различных экранов. Например: экран загрузки, экран авторизации, экран профиля, экран настроек и тд.  
А каждую фичу, в свою очередь, можно разделить на три логических блока:
- UI (User Interface) - то, как выглядит экран приложения (кнопоки, поля для ввода, картинки, фон и пр.)
- Работа с данными - почти в каждой фиче приложения происходит какя-то работа с данными, например:
  - на экране регистрации - юзер ввел свои данные и нажал кнопку "Зарегистрироваться", нужно отправить запрос о регистрации на сервер и дождаться ответа
  - на экране списка новостей - последние 10-20 как правило сохраняют в базу данных на устройстве, чтобы при отсутсвии интернета что-то все равно отображалось, поэтому помимо получения новостей от сервера происходит сохранение новостей в БД
- Логика работы самого приложения - непосредственно бизнес-логика
    - что должно произойти, когда юзер нажмет кнопку "Зарегистрироваться"
    - как часто нужно обновлять статус отправленных сообщений, чтобы юзер увидел, что собеседник их прочитал
    - и тд

В принципе, ничего не мешает нам реализовать UI, логику работы с данными и бизнес логику внутри одного класса. Пока проект будет небольшим, это будет казаться удобным, но как только 
Однако, такой проект скоро станет очень тяжело поддерживать, ведь все перемешается и найти ошибочное место будет не так уж и легко  ***ДОПИСАТЬ***

***Что предлагает нам MVVM?***
- принцип следующий: разделить задачу на три компонента Model, View и ViewModel
    - Model - модель данных, отвечает за работу с данными (обращение к БД или серверу). Она умеет только работать с данными, получать и сохранять. Модель знает о том, какие методы для работы с данными хочет получить ViewModel и реализует их
    - View - отвечает только за UI. Не содержит в себе никакой бизнес-логики, думать вообще не умеет 
    - ViewModel - содержит в себе только бизнес-логику приложения, работает с Model и View следующим образом:
        при создании вью модели для экрана профиля пользователя объявляем интерфейс: UserProfileRepository  

    - разберем работу ViewModel-и на примере:
        - Юзер ввел номер телефона в поле ввода
        - Нажал кнопку "Отправить код подтверждения"
        - ViewModel получила уведомление о том, кака кнопка нажата, 
        - проверила что в поле введен валидный номер телефона
        - вызвала метод у модели, модель там кинула запрос на сервер, сервер сам все дальше подумал и прислал нам код подтверждения, который мы
        - ViewModel сказала View, чтобы та скрыла поле с номером телефона и показала поле в которое можно будет ввести код подтверждени и кнопку "Отправить повторно"
- Бонусы на андроиде
    - так как вьюмодель с гугловых компонентов, онп не пересоздается, когда пересоздается Activity или Fragment  
    
***Что нам это дало?***
- теперь у нас есть четкая структура, и наши компоненты независимы друг от друга:
    - вью хочет только экземпляр вьюмодели
    - вьюмодель при создании хочет только кого-нибудь, кто реализует необходимые ей методы
    - Модель (репозиторий) просто реализует методы разных вьюмоделей, она вообще ничего не знает о вьюхах 
- легкость в исправлении ошибок - теперь для исправления UI, бизнес-логики или логики работы с данными мы сразу знаем в каком месте требуются изменения. 

читнуть про [VM](https://developer.android.com/topic/libraries/architecture/viewmodel)


## Observer
прочитать про [паттерн](https://blog.mestwin.net/observer-pattern-in-kotlin-design-patterns/)
В Андроиде есть лайвдаты, мы, используя moko-mvvm перетащили их в общий код

Можно записать видео-разбор какого-нибудь экрана какого-нибудь приложения. Показать вьюмодель, показать два экрана - iOS и Android, показать что оба дергают вьюмодель, оба получают данные от вьюмодели, которые вьюмодель берет из репозитория. Что при желании легко и просто поменять логику во вьюмодели, можно поменять iOS и Android UI, что платформа не думает и тд

После этого отправить сделать практику по шагам, или показать moko-mvvm и потом к практике отправлять

## Библиотека moko-mvvm

- [GitHub](https://github.com/icerockdev/moko-mvvm) библиотеки

- Посмотреть и повторить самостоятельно проект из видео [moko-mvvm #1](https://youtu.be/qe8FcIQEmyA)

Добавить тест в конце в гуглформе про Observer
