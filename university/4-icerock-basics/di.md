---
sidebar_position: 6
---

# Внедрение зависимостей и ресурсов

Каждый наш проект состоит из модулей. Модули никак не связанны друг с другом. Во многих модулях происходит работа с сетью и сервером,  
***дописать тут, плавный переход нужен***  
Например: модуль авториазации не работает с сетью самостоятельно, а делает это через общий репозиторий. Для этого он объявляет интерфейс с функцией `signIn`  
```kotlin
interface AuthRepository {
    fun signIn(phoneNumber: String, authCode: String)
}
```
А в своем конструкторе объявляет поле, типа этого интерфеса:
```kotlin
class AuthViewModel(
    ...
    repository: AuthRepository,
    ...
) 
```

Таким образом вьюмодель как-бы говорит: мне для работы нужен объект типа `AuthRepository`, потому что у него есть нужный мне метод `signIn`. Мне абсолютно не важно, кто и как будет его реализовывать. 
Это называется `Dependency inversion` - инверсия зависимостей. Когда кто-то диктует наружу, как его использовать.

Также, для каждого модуля есть своя `factory`. Ее задача - создавать уже настроенные объекты фичи

У каждого модля есть своя фактори.  
Задача фактори - создавать объекты фичи сразу настроенные, чтобы в них уже были все необходимые зависимости. 
То же самое косается и фабрик, у них также есть свои требования наружу.

Главная фабрика в проекте и его стартовая точка - это `SharedFactory`, она объединяет все остальные фабрики фичей и свзяывает их друг с другом. Через `SharedFactory` можно получить все, что нужно из общего кода.   Модуль `mppLibrary` единственный, который знает обо всех фичах в приложении. Именно он соединяет каждую фичу межу собой.

Последние настройки, которые требуются общему коду - это настройки `SharedFactory`, которая настраивается уже на платформе 

Пример параметров, которые необходимы `SharedFactory`: 
- адрес сервера (чтобы платформы своими инструментами могли регулировать dev/stage/prod)
- multiplatform-settings
- оповещение, что разлогинились


конструктор ШФ - то, что нужно общей логике от внешнего мира, чтобы работать

через ШФ можно получить все из общего кода 

Про SharedFactory, про фактори фичей и тд

SF - обладает всеми фактори фичей, умеет их создавать предоставляя им зависимости
фактори фичей - умеют создавать все то, что им надо - вьюмодели и тд
ресурсы - тоже зависимость. Фича говорит- вот интерфейс, вот эти ресурсы мне нужны снаружи

Shared видит что нужны такие ресурсы, делает реализацию интерфейса и передает в фичу

1. Шаблоном создаем ViewModel
1. Если нужны какие-то мультиплатформенные строчки - делаем интерфейс Strings, там объявляем переменные строк, которые нам нужны
   ```kotlin
        interface Strings {
             val examplePlaceholder: StringDesc
             val examplePlaceholder2: StringDesc
        }
   ```
   И в конструкторе просим реализацию этого интерфейса, SharedFactory при создании нашей VM прокинет нам необходимые строчки
1. Рядом с классом VM создаем интерфейс с созвучным фиче названием: RegistrationRepository. Там мы описываем все методы для работы с данными, которые нужны нашей вьюмодели 
1. В едином классе Repository мы добавляем, что реализуем в том числе и этот интерфейс RegistrationRepository, реализуем все методы, которые хочет эта вьюмодель и передаем ей в качестве репозитория себя: таким образом, класс репозитория у нас один, в нем реализованы все методы для работы с данными, которые нужны вьюмоделям. Но каждая вьюмодель видит только те методы, которые описаны в ее интерфейсе репозитория 

Например: вьюмодели RegistrationViewModel для своей работы нужны методы:
- sendCode(phoneNumber: String) - чтобы сервер отправил код подтверждения на телефон юзеру
- confirmCode(code: String) - чтобы сервер проверил, правильный ли введен код подтверждения
- saveUser(password: String) - чтобы завершить регистрацию и сохранить юзера на сервере

Соответственно, будет создан интерфейс:
```kotlin
interface RegistrationRepository {
    suspend fun sendCode(
       phoneNumber: String
    ): Int

    suspend fun confirmCode(
       code: String
    )

   suspend fun saveUser(
       password: String
    ): User
}

```

```mermaid

classDiagram
class MR

class SharedFactory

class RegistrationFactory {
   interface Strings : RegistrationViewModel.Strings
}

class NewsHistoryFactory {
   interface Strings : NewsHistoryViewModel.Strings
}

class RegistrationViewModel{
   interface Strings
}

class NewsHistoryViewModel{
   interface Strings
}

SharedFactory --> MR
SharedFactory --> RegistrationFactory
SharedFactory --> NewsHistoryFactory

RegistrationFactory --> RegistrationViewModel
NewsHistoryFactory --> NewsHistoryViewModel

```


## Библиотека moko-resources

[github](https://github.com/icerockdev/moko-resources)

отправить читать ридми

Описать что делают, как помогают на мульиплатформе

рассказать про master.sh, какие есть параметры, как найти гуглтаблицу по файлу

задание: подключить библиотеку к проекту, вынести общие ресурсы

## master.sh

Для локализации мы используем интеграцию с google sheets т.к. можно передать заказчику и он сможет сам задать строчки 