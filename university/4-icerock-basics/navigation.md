---
sidebar_position: 8
---

# Навигация между экранами

## Android 

Для навигации в Android-приложении мы будем использовать Navigation component
[офф статья](https://developer.android.com/guide/navigation)

## Navigation component - практическое задание
[get started](https://developer.android.com/guide/navigation/navigation-getting-started)

## iOS

[статья в разделе обучения](/learning/ios/navigation).

[видео](https://www.youtube.com/watch?v=Pt9TGFzLVzc) - разбор использования `ApplicationCoordinator` для навигации между экранами

В наших проектах, для верстки и навигации на iOS мы больше не будем использовать `.storyboard`, вместо этого мы будем пользоваться следующими инструментами:
- `AppCoordinator` - главный координатор приложения, который будет запускать другие координаторы в зависимости от входных данных
- Другие координаторы - отвечают за свои зоны приложения (авторизация, просмотр новостей, редактирование профиля и тд)
- `.xib` и code для верстки - экраны верстаем в `.xib`, navigation items и более сложные настройки делаем через код

## ApplicationCoordinator - практическое задание

В качестве практики предлагаем вам потренироваться в использовании `ApplicationCoordinator`. Ориентируясь на [проект](https://github.com/pegurov/CoordinatorsDemo) из [видео](https://www.youtube.com/watch?v=Pt9TGFzLVzc) сделать следующее приложение:
- всего 2 экрана: `AuthViewController` и `HomeViewController` и 3 координатора: `AppCoordinator`, `AuthCoordinator` и `HomeCoordinator`
- `AuthViewController` - экран регистрации, добавьте сюда поле для ввода никнейма и кнопку "Login"
- `HomeViewController` - основной экран приложения, добавьте сюда `Label` с приветствием юзера по никнейму и кнопку "Logout"
- никнейм сохранять в параметры устройства используя `NSUserDefaults`
- использовать `ApplicationCoordinator` для первичной навигации - если никнейм есть - значит запускать `GreetingCoordinator`, иначе запускать `AuthCoordinator`
- не используйте `.storyboard`, создайте необходимые контроллеры и свяжите их с `.xib`
- для `UserEditViewController` используйте `.xib` с таким же именем, а для `CitiesViewController` создайте `.xib` с отличающимся именем

## KMM
Логика переходов между экранами, как и другая логика приложения, находится во viewModel-и. Поэтому `viewModel` должна как-то сообщать фрагменту или viewController'y, что пора переходить на другой экран.

Разберем общепринятый подход, и подход, использующийся у нас в компании

### Channel

Чаще всего для управлением переходов между экранами со стороны вьюмодели используют [Channel](https://kotlinlang.org/docs/channels.html). При необходимости перейти на другой экран viewModel помещает в `channel` объекты дата-класса, например: RouteToMainScreen, RouteToAuthScreen, RouteToSettingsScreen. Fragment и viewController слушают этот канал, и, когда в канале появляется новый объект, определяют по нему на какой экран переходить.

Это хороший подход, однако у него есть один недостаток, который проявляется при разработке мультиплатформенного приложения.

Представим, что мы обрабатываем работу с каналом во фрагменте: каждый новый объект из канала обрабатывается when-ом. Если все объекты из дата-класса обработаны в when, то на Android ветка else не потребуется.  
В iOS же, даже при переборе всех объектов дата-класса в when, нужно будет добавить ветку else.  
Теперь, предположим, что нам понадобилось добавить еще один объект в дата класс для событий, которые кидает вьюмодель.  
Котлин нам выдаст ошибку при компиляции, надо будет добавить в when обработку еще одного объекта - нового.  
А Swift нам ничего не подскажет, потому что новый объект будет обрабатываться в ветке else. Из-за этого, логика перехода на iOS нарушится. Поиск ошибки может занять некоторое время, в зависимости от знаний разработчика.  
Чтобы не сталкиваться с этим на практике, мы, для отпраки событий от вьюмодели используем другой подход - с помощью EventsDispatcher из [moko-mvvm](https://github.com/icerockdev/moko-mvvm).  

### EventsDispatcher

EventsDispatcher — это специальный класс, который автоматически удаляет наблюдателей из жизненного цикла и буферизует входные события, пока слушатель не подключен (на стороне Android).? - самому не понятно объснение из ридми

Все, что нужно сделать во вьюмодели - это получить объект eventsDispatcher и реализовать интерфейс `EventsDispatcherOwner<T : Any>` и, в качестве параметра, передать туда реализованный во вьюмодели интерфейс 
```kotlin
interface EventsDispatcherOwner<T : Any> {
    val eventsDispatcher: EventsDispatcher<T>
}
```

Вьюмодель реализует интерфейс с перечислением всех методов, которые ей нужны 

```kotlin 
interface EventsListener {
    fun routeToSomeoneScreen()
}
```

Фрагмент, в свою очередь, должен реализовать метод, объявленный в интерфейсе `TestViewModel.EventsListener`

```kotlin
override fun routeToSomeoneScreen() {
    findNavController().navigate(R.id.action_testFragment_to_someoneFragment)
}
```

Теперь, когда логика во вьюмодели дойдет до перехода на SomeoneScreen, она просто закинет это событие в диспатчер
Если в момент передачи события во фрагмент или активити они, по какой-то причине (пересоздавлись, еще что-нибудь) не получили это событие, то когда они снова подпишутся к текущему диспатчеру вьюмодели, он доставит им то, что доставить не смог

``` kotlin
eventsDispatcher.dispatchEvent { routeToSomeoneScreen() }
```

Подход `EventDispatcher` - это такой интерфейс, который существует вместе с `ViewModel`
диспатчер доставляет события до фрагментов
логика решила, что пора переходить на следующий экран, диспатчер доставит это событие 

К этому моменту уже и тем и тем пользовались, не знаю нужна ли практика именно тут

## Передача идентификаторов при навигации

главное - отбить желание передавать большие объекты
- может быть большой и не влезть на андроиде в бандл
- модельку придется приводить на android к Parcelable

Гораздо правильнее передать id-шник, чтобы он у репозитория попросил данные, которые ему нужны  

Объяснить проблему - надо что-то передавать при навигации

Показать примеры как это делать 

Попросить повторить 