---
sidebar_position: 7
---

# Навигация между экранами

## Android 

Для навигации в Android-приложении мы будем использовать [Navigation component](https://developer.android.com/guide/navigation).  
Вы уже читали о ней в блоке [Экраны и навигация](/university/android-basics/user-interface#экраны-и-навигация), повторите при необходимости.

## iOS

Для понимания того, как будет реализована навигация в `iOS` прилоежниях на проектах, ознакомьтесь со [статьей](/learning/ios/navigation) и материалами из нее.

В наших проектах, для верстки и навигации на iOS мы больше не будем использовать `.storyboard`, вместо этого мы будем пользоваться следующими инструментами:
- `AppCoordinator` - главный координатор приложения, который будет запускать другие координаторы в зависимости от входных данных
- Другие координаторы - отвечают за свои зоны приложения (авторизация, просмотр новостей, редактирование профиля и тд)
- `.xib` и `код` для верстки
    - экраны верстаем в `.xib`
    - `navigation items` и более сложные настройки делаем через `код`

## ApplicationCoordinator - практическое задание

В качестве практики предлагаем вам потренироваться в использовании `ApplicationCoordinator`. На основе [mobile-moko-boilerplate](https://gitlab.icerockdev.com/scl/boilerplate/mobile-moko-boilerplate) сделать следующее приложение:
- всего 2 экрана: `AuthViewController` и `HomeViewController` и 3 координатора: `AppCoordinator`, `AuthCoordinator` и `HomeCoordinator`
- `AuthViewController` - экран регистрации, добавьте сюда поле для ввода никнейма и кнопку "Login"
- `HomeViewController` - основной экран приложения, добавьте сюда `Label` с приветствием юзера по никнейму и кнопку "Logout"
- никнейм сохранять в параметры устройства используя `NSUserDefaults`
- использовать `ApplicationCoordinator` для первичной навигации - если никнейм есть - значит запускать `GreetingCoordinator`, иначе запускать `AuthCoordinator`
- не используйте `.storyboard`, создайте необходимые контроллеры и свяжите их с `.xib`
- для `UserEditViewController` используйте `.xib` с таким же именем, а для `CitiesViewController` создайте `.xib` с отличающимся именем

## KMM
Для начала, освежите в памяти что такое [события/действия](/learning/android/states-events#событие-действие), для чего они нужны и как реализуются на `Android`.
За всю логику в приложении, в том числе и за принятие решения, когда нужно перейти на другой экран отвечает `viewModel`. Поэтому `viewModel` должна как-то сообщать фрагменту или `viewController`-y, что нужно выполнить какое-то действие (`Action`).

Разберем два подхода для передачи событий от вьюмодели на UI: 
- используя [Flow](https://kotlinlang.org/docs/flow.html)
- используя `EventsDispatcher` из [moko-mvvm](https://github.com/icerockdev/moko-mvvm).

### Flow  

В [статье](/learning/android/states-events) про состояния и события вы уже ознакомились с передачей событий на `Android` используя `Flow APIs`.  
Однако, теперь нам нужно отправлять такие действия из общего кода, который потом подключится к `iOS` и `Android` приложениям. 
Проблема в том, что на `iOS` не удастся использовать `Flow APIs`, потому что там нет параметризированных интерфейсов, и дженерик просто пропадет, а все объекты во `Flow` будут `Any?`.

Проблема норме раз - дженерики ни впихнуть
Проблема номер два - sealed interface не работает как enum на iOS, ветка else все портит

При необходимости перейти на другой экран `viewModel` помещает во `flow` объекты `sealed interface`, например: `RouteToMainScreen`, `RouteToAuthScreen`, `RouteToSettingsScreen`. `Fragment` и `viewController` слушают этот флоу, и, когда он меняет состояние на новое, определяют по нему на какой экран переходить.
Это хороший подход, однако у него есть один недостаток, который проявляется при разработке мультиплатформенного приложения.

Представим, что мы подписались на `flow` во фрагменте: каждый новый объект обрабатывается `when`-ом. Если все объекты из `sealed interface`-а обработаны в `when`, то на `Android` ветка `else` не потребуется.  
В `iOS` же, `interface` не преобразуется в `enum`, из-за чего даже при переборе всех объектов в `when`, нужно будет добавить ветку `else`.  
Теперь, предположим, что нам понадобилось добавить еще один объект в `sealed interface` для событий, которые кидает вьюмодель.  
Котлин нам выдаст ошибку при компиляции, надо будет добавить в `when` обработку еще одного объекта - нового.  
А `Swift` нам ничего не подскажет, потому что новый объект будет обрабатываться в ветке `else`. Из-за этого, логика перехода на `iOS` нарушится. Поиск ошибки может занять некоторое время, в зависимости от знаний разработчика.  
Чтобы не сталкиваться с этим на практике, мы, для отправки событий от вьюмодели долгое время использовали другой подход - с помощью `EventsDispatcher` из [moko-mvvm](https://github.com/icerockdev/moko-mvvm).  

Однако, благодаря недавно появившейся библиотеке [moko-kswift](https://github.com/icerockdev/moko-kswift) мы теперь можем использовать `sealed interface` в общем коде, и нормально обрабатывать на `iOS`
А для того, чтобы использовать `Flow` в общем коде, мы будем использовать `Cflow<T>` - класс, реализующий интерфейс `FLow`, который можно параметризировать, в отличие от интерфейса 


### EventsDispatcher

Если нет подписчиков - он буферизирует события, которые нужно кинуть. Если появляется подписчик - кидает событие. Нужно это для андроида, потому что там экраны могут пересоздаваться (поворот-переворот и тд)

Класс содержит всего один метод - `dispatchEvent`, принимает лямбду - что за ивент нужно послать
на стороне андроида делаем bind, который lifecycleOwner, он сразу устанавливает обработчики на методы ЖЦ `onResume` и `onPause`
в `onPause` он(фрагмент) прекращает получать события, а в `onResume` возвращает подписчика, за счет этого он получает все те события, которые пропустил.

Все, что нужно сделать во вьюмодели - это получить объект `eventsDispatcher`.
Вьюмодель объявляет интерфейс с перечислением всех методов, которые ей нужны 

```kotlin 
interface EventsListener {
    fun routeToSomeoneScreen()
}
```

Фрагмент, в свою очередь, должен реализовать метод, объявленный в интерфейсе `TestViewModel.EventsListener`

```kotlin
override fun routeToSomeoneScreen() {
    findNavController().navigate(R.id.action_testFragment_to_someoneFragment)
}
```

Теперь, когда логика во вьюмодели дойдет до перехода на SomeoneScreen, она просто закинет это событие в диспатчер
Если в момент передачи события во фрагмент или активити они, по какой-то причине (пересоздавались, еще что-нибудь) не получили это событие, то когда они снова подпишутся к текущему диспатчеру вьюмодели, он доставит им то, что доставить не смог

``` kotlin
eventsDispatcher.dispatchEvent { routeToSomeoneScreen() }
```

Ндо про подключение на iOS 

Надо практику + 

## Передача идентификаторов при навигации

Нельзя передавать лямбду в dispatchEvent, потому что на Android мы не сможем ее никуда сохранить и при пересоздании экрана она пропадет
Тут написать про передачу idшек, никаких лямбд. iOS вместит в себя че хочешь, а android нет, поэтому большие объекты тоже нельзя
