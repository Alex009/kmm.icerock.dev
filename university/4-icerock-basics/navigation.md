---
sidebar_position: 7
---

# Навигация между экранами

Android - https://developer.android.com/guide/navigation

[видео](https://www.youtube.com/watch?v=Pt9TGFzLVzc) - разбор использования `ApplicationCoordinator` для навигации между экранами

В наших проектах, для верстки и навигации на iOS мы больше не будем использовать `.storyboard`, вместо этого мы будем пользоваться следующими инструментами:
- `AppCoordinator` - главный координатор приложения, который будет запускать другие координаторы в зависимости от входных данных
- Другие координаторы - отвечают за свои зоны приложения (авторизация, просмотр новостей, редактирование профиля и тд)
- `.xib` и code для верстки - экраны верстаем в `.xib`, navigation items и более сложные настройки делаем через код

## ApplicationCoordinator - практическое задание

В качестве практики предлагаем вам потренироваться в использовании `ApplicationCoordinator`. Ориентируясь на [проект](https://github.com/pegurov/CoordinatorsDemo) из [видео](https://www.youtube.com/watch?v=Pt9TGFzLVzc) сделать следующее приложение:
- всего 2 экрана: `AuthViewController` и `HomeViewController` и 3 координатора: `AppCoordinator`, `AuthCoordinator` и `HomeCoordinator`
- `AuthViewController` - экран регистрации, добавьте сюда поле для ввода никнейма и кнопку "Login"
- `HomeViewController` - основной экран приложения, добавьте сюда `Label` с приветствием юзера по никнейму и кнопку "Logout"
- никнейм сохранять в параметры устройства используя `NSUserDefaults`
- использовать `ApplicationCoordinator` для первичной навигации - если никнейм есть - значит запускать `GreetingCoordinator`, иначе запускать `AuthCoordinator`
- не используйте `.storyboard`, создайте необходимые контроллеры и свяжите их с `.xib`
- для `UserEditViewController` используйте `.xib` с таким же именем, а для `CitiesViewController` создайте `.xib` с отличающимся именем


показать на примере проекта

EventDispatcher - у нас штука есть в mvvm, с привязкой на ЖЦ фрагмента/активити

умеет сообщать, что надо сделать
если фрагмент или активити пересоздаются, то они после пересоздания сразу подписываются к текущему eventDispatcher вьюмодели, и получают то, что он хотел доставить
если может, то доставляет все события сразу, если не может то запоминает что ему нужно доставить, и при первой возможности доставляет


чаще делают не интерфейс как у нас, а канал, в который кидают объекты датакласса типа (RouteToMain, RouteToAuth) и тдёи когда надо чето сделать, они кидают в канал
плюсы:
- работает красивый when (в чисто котлин мире)
минусы  
- не так красиво приходит на swift, когда все кейсы переберешь, он заставит добавить еще else. И когда в коммон коде добавим еще один кейс, то в ios сломаемся потому что там типа else уже есть

```kotlin 
// вьюмодель MyTestViewModel реализует интерфейс
EventsDispatcherOwner<MyTestViewModel.EventsListener>

// у себя, в реализации интерфейса пишет методы, которые будет кидать

interface EventsListener {
    fun routeToProfile(id: Int)
}
```
К этому моменту уже и тем и тем пользовались, не знаю нужна ли практика именно тут

## Передача идентификаторов при навигации

главное - отбить желание передавать большие объекты
- может быть большой и не влезть на андроиде в бандл
- модельку придется приводить на android к Parcelable

Гораздо правильнее передать id-шник, чтобы он у репозитория попросил данные, которые ему нужны  

Объяснить проблему - надо что-то передавать при навигации

Показать примеры как это делать 

Попросить повторить 