---
sidebar_position: 7
---

# Навигация между экранами

## Android 

Для навигации в Android-приложении мы будем использовать Navigation component
[офф статья](https://developer.android.com/guide/navigation)

## Navigation component - практическое задание
[get started](https://developer.android.com/guide/navigation/navigation-getting-started)

## iOS

[статья в разделе обучения](/learning/ios/navigation).

В наших проектах, для верстки и навигации на iOS мы больше не будем использовать `.storyboard`, вместо этого мы будем пользоваться следующими инструментами:
- `AppCoordinator` - главный координатор приложения, который будет запускать другие координаторы в зависимости от входных данных
- Другие координаторы - отвечают за свои зоны приложения (авторизация, просмотр новостей, редактирование профиля и тд)
- `.xib` и code для верстки - экраны верстаем в `.xib`, `navigation items` и более сложные настройки делаем через код

## ApplicationCoordinator - практическое задание

В качестве практики предлагаем вам потренироваться в использовании `ApplicationCoordinator`. На основе [mobile-moko-boilerplate](https://gitlab.icerockdev.com/scl/boilerplate/mobile-moko-boilerplate) сделать следующее приложение:
- всего 2 экрана: `AuthViewController` и `HomeViewController` и 3 координатора: `AppCoordinator`, `AuthCoordinator` и `HomeCoordinator`
- `AuthViewController` - экран регистрации, добавьте сюда поле для ввода никнейма и кнопку "Login"
- `HomeViewController` - основной экран приложения, добавьте сюда `Label` с приветствием юзера по никнейму и кнопку "Logout"
- никнейм сохранять в параметры устройства используя `NSUserDefaults`
- использовать `ApplicationCoordinator` для первичной навигации - если никнейм есть - значит запускать `GreetingCoordinator`, иначе запускать `AuthCoordinator`
- не используйте `.storyboard`, создайте необходимые контроллеры и свяжите их с `.xib`
- для `UserEditViewController` используйте `.xib` с таким же именем, а для `CitiesViewController` создайте `.xib` с отличающимся именем

## KMM
За всю логику в приложении, в том числе и за принятие решения, когда нужно перейти на другой экран отвечает `viewModel`. Поэтому `viewModel` должна как-то сообщать фрагменту или `viewController`-y, что пора переходить на другой экран.

Разберем два подхода для передачи событий от вьюмодели на UI: 
- используя [Channel](https://kotlinlang.org/docs/channels.html)
- используя `EventsDispatcher` из [moko-mvvm](https://github.com/icerockdev/moko-mvvm).

### Channel

В [статье](/learning/android/states-events) про состояния и события вы уже ознакомились с передачей событий используя `Flow APIs`, рассмотрим еще похожий подход, используя [Channel](https://kotlinlang.org/docs/channels.html).
При необходимости перейти на другой экран `viewModel` помещает в `channel` объекты дата-класса, например: `RouteToMainScreen`, `RouteToAuthScreen`, `RouteToSettingsScreen`. `Fragment` и `viewController` слушают этот канал, и, когда в канале появляется новый объект, определяют по нему на какой экран переходить.
Это хороший подход, однако у него есть один недостаток, который проявляется при разработке мультиплатформенного приложения.

Представим, что мы обрабатываем работу с каналом во фрагменте: каждый новый объект из канала обрабатывается `when`-ом. Если все объекты из дата-класса обработаны в `when`, то на `Android` ветка `else` не потребуется.  
В `iOS` же, даже при переборе всех объектов дата-класса в `when`, нужно будет добавить ветку `else`.  
Теперь, предположим, что нам понадобилось добавить еще один объект в дата класс для событий, которые кидает вьюмодель.  
Котлин нам выдаст ошибку при компиляции, надо будет добавить в when обработку еще одного объекта - нового.  
А `Swift` нам ничего не подскажет, потому что новый объект будет обрабатываться в ветке `else`. Из-за этого, логика перехода на `iOS` нарушится. Поиск ошибки может занять некоторое время, в зависимости от знаний разработчика.  
Чтобы не сталкиваться с этим на практике, мы, для отправки событий от вьюмодели используем другой подход - с помощью `EventsDispatcher` из [moko-mvvm](https://github.com/icerockdev/moko-mvvm).  

### EventsDispatcher

Класс содержет всего один метод - `dispatchEvent`, принимает лямбду - что за ивент нужно послать
на стороне андроида делаем bind, который lifecycleOwner, он сразу устанавливает обработчики на методы ЖЦ `onResume` и `onPause`
в `onPause` он(фрагмент) перкращает получать события, а в `onResume` возвращает подписчика, за счет этого он получает все те события, которые пропустил&


`EventsDispatcher` — это специальный класс, который автоматически удаляет наблюдателей из жизненного цикла и буферизует входные события, пока слушатель не подключен (на стороне Android).? - самому не понятно объяснение из ридми

Все, что нужно сделать во вьюмодели - это получить объект `eventsDispatcher`.
Вьюмодель объявляет интерфейс с перечислением всех методов, которые ей нужны 

```kotlin 
interface EventsListener {
    fun routeToSomeoneScreen()
}
```

Фрагмент, в свою очередь, должен реализовать метод, объявленный в интерфейсе `TestViewModel.EventsListener`

```kotlin
override fun routeToSomeoneScreen() {
    findNavController().navigate(R.id.action_testFragment_to_someoneFragment)
}
```

Теперь, когда логика во вьюмодели дойдет до перехода на SomeoneScreen, она просто закинет это событие в диспатчер
Если в момент передачи события во фрагмент или активити они, по какой-то причине (пересоздавлись, еще что-нибудь) не получили это событие, то когда они снова подпишутся к текущему диспатчеру вьюмодели, он доставит им то, что доставить не смог

``` kotlin
eventsDispatcher.dispatchEvent { routeToSomeoneScreen() }
```

Ндо про подключение на iOS 

Надо практику + 

## Передача идентификаторов при навигации

Нельзя передавать лямбду в dispatchEvent, потому что на Android мы не сможем ее никуда сохранить и при пересоздании экрана она пропадет  

главное - отбить желание передавать большие объекты
- может быть большой и не влезть на андроиде в бандл
- модельку придется приводить на android к Parcelable

Гораздо правильнее передать id-шник, чтобы он у репозитория попросил данные, которые ему нужны  

Объяснить проблему - надо что-то передавать при навигации

Показать примеры как это делать 

Попросить повторить 